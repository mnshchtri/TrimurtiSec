import socket
import subprocess
import json
import os
import time
import yaml
from rich.console import Console
from rich.progress import Progress
from typing import List, Dict, Set
from datetime import datetime
from fpdf import FPDF
from trimurti.utils.enhanced_progress import TrimurtiProgressTracker, AnimatedSpinner, create_hacking_simulation_progress

console = Console()

class VulnerabilityScanner:
    def __init__(self, target):
        self.target = target
        self.live_subdomains = set()
        # Create reports directory
        os.makedirs('reports', exist_ok=True)
        self._discover_live_subdomains()

    def _discover_live_subdomains(self):
        """Discover live subdomains from existing scan results or perform basic discovery"""
        # First, try to load from existing subdomain discovery results
        if os.path.exists('reports/httpx_results.json'):
            console.print("[cyan]Loading live subdomains from previous scan results...[/cyan]")
            with open('reports/httpx_results.json', 'r') as f:
                for line in f:
                    try:
                        result = json.loads(line.strip())
                        url = result.get('url', '').replace('https://', '').replace('http://', '')
                        if url:
                            self.live_subdomains.add(url)
                    except json.JSONDecodeError:
                        continue
            
            if self.live_subdomains:
                console.print(f"[green]Found {len(self.live_subdomains)} live subdomains from previous scan[/green]")
                return
        
        # If no previous results, perform basic subdomain discovery
        console.print("[cyan]No previous subdomain data found. Performing basic discovery...[/cyan]")
        
        # Add the main domain as a target
        if not self._is_ip_address(self.target):
            # Test if main domain is accessible
            try:
                cmd = f"httpx -u {self.target} -silent -mc 200,301,302 -json -o reports/temp_httpx.json"
                process = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
                
                if os.path.exists('reports/temp_httpx.json'):
                    with open('reports/temp_httpx.json', 'r') as f:
                        for line in f:
                            try:
                                result = json.loads(line.strip())
                                url = result.get('url', '').replace('https://', '').replace('http://', '')
                                if url:
                                    self.live_subdomains.add(url)
                            except json.JSONDecodeError:
                                continue
                    os.remove('reports/temp_httpx.json')
            except Exception:
                pass
        
        # If it's an IP address, add it directly
        if self._is_ip_address(self.target):
            self.live_subdomains.add(self.target)
        elif not self.live_subdomains:
            # Add main domain anyway for scanning
            self.live_subdomains.add(self.target)

    def scan_vulnerabilities(self) -> str:
        """Run comprehensive vulnerability scanning"""
        if not self.live_subdomains:
            return "No live targets found for vulnerability scanning."
        
        # Create enhanced progress tracker
        tracker = TrimurtiProgressTracker('brahma', self.target)
        tracker.create_mode_header()
        
        console.print(f"[cyan]Starting vulnerability assessment on {len(self.live_subdomains)} targets...[/cyan]")
        
        # Vulnerability scanning steps
        vuln_steps = [
            "Initializing vulnerability scanning engines...",
            "Installing and updating vulnerability databases...",
            "Performing comprehensive security assessment...",
            "Analyzing SSL/TLS configurations...",
            "Detecting web technologies and frameworks...",
            "Compiling vulnerability findings..."
        ]
        
        vuln_results = {
            'nuclei_findings': [],
            'ssl_findings': [],
            'whatweb_findings': [],
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'info_count': 0
        }
        
        with tracker.create_scan_progress(len(vuln_steps)) as progress:
            for i, step in enumerate(vuln_steps):
                task = progress.add_task(step, total=100)
                
                # Execute actual vulnerability scanning steps
                if i == 1:  # Install and update tools
                    self._ensure_vuln_tools_installed()
                elif i == 2:  # Run Nuclei scan
                    urls_file = self._create_urls_file()
                    vuln_results['nuclei_findings'] = self._run_nuclei_scan(urls_file)
                elif i == 3:  # SSL analysis
                    vuln_results['ssl_findings'] = self._run_ssl_scan()
                elif i == 4:  # Technology detection
                    vuln_results['whatweb_findings'] = self._run_whatweb_scan()
                elif i == 5:  # Calculate metrics
                    self._calculate_vulnerability_metrics(vuln_results)
                
                # Animate progress
                for j in range(100):
                    progress.advance(task, 1)
                    if i in [1, 2, 3, 4]:  # Add delay for actual work phases
                        time.sleep(0.01)
        
        # Show completion statistics
        vuln_stats = {
            "Target": self.target,
            "Targets Scanned": len(self.live_subdomains),
            "Total Vulnerabilities": vuln_results['total_vulnerabilities'],
            "Critical Issues": vuln_results['critical_count'],
            "High Severity": vuln_results['high_count'],
            "Medium Severity": vuln_results['medium_count'],
            "Low Severity": vuln_results['low_count'],
            "Status": "Vulnerability Scan Complete"
        }
        tracker.show_completion_stats(vuln_stats)
        
        # Generate comprehensive vulnerability report
        report_file = f'reports/vulnerability_scan_report_{self.target.replace(".", "_")}.pdf'
        self._generate_vulnerability_report(vuln_results, report_file)
        console.print(f"[green]Vulnerability report saved to: {report_file}[/green]")
        
        return f"Vulnerability scanning complete. Found {vuln_results['total_vulnerabilities']} potential security issues."

    def _create_urls_file(self) -> str:
        """Create URLs file for scanning"""
        urls_file = 'reports/live_targets.txt'
        with open(urls_file, 'w') as f:
            for target in self.live_subdomains:
                if self._is_ip_address(target):
                    f.write(f"http://{target}\n")
                    f.write(f"https://{target}\n")
                else:
                    f.write(f"https://{target}\n")
                    f.write(f"http://{target}\n")
        return urls_file

    def _ensure_vuln_tools_installed(self):
        """Ensure vulnerability scanning tools are installed"""
        console.print("[cyan]Checking vulnerability scanning tools...[/cyan]")
        
        # Check Nuclei
        try:
            subprocess.run(['nuclei', '-version'], capture_output=True, check=True)
            console.log("Nuclei is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Installing Nuclei...[/yellow]")
            try:
                subprocess.run([
                    'go', 'install', '-v', 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest'
                ], check=True)
                console.log("Nuclei installed successfully")
            except Exception as e:
                console.print(f"[red]Failed to install Nuclei: {e}[/red]")
        
        # Update Nuclei templates
        try:
            console.print("[cyan]Updating Nuclei templates...[/cyan]")
            subprocess.run(['nuclei', '-update-templates'], capture_output=True, timeout=60)
            console.log("Nuclei templates updated")
        except Exception as e:
            console.print(f"[yellow]Could not update Nuclei templates: {e}[/yellow]")

    def _run_nuclei_scan(self, urls_file: str) -> list:
        """Run Nuclei vulnerability scanner"""
        nuclei_findings = []
        nuclei_output = 'reports/nuclei_vulnerability_results.json'
        
        try:
            console.print("[cyan]Running Nuclei vulnerability scan...[/cyan]")
            
            # Run Nuclei with comprehensive templates
            cmd = [
                'nuclei',
                '-list', urls_file,
                '-json',
                '-o', nuclei_output,
                '-severity', 'critical,high,medium,low',
                '-tags', 'cve,xss,sqli,rce,lfi,ssrf,redirect,exposure,misconfig',
                '-timeout', '15',
                '-retries', '3',
                '-rate-limit', '50',
                '-stats'
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            if os.path.exists(nuclei_output):
                with open(nuclei_output, 'r') as f:
                    for line in f:
                        try:
                            finding = json.loads(line.strip())
                            nuclei_findings.append(finding)
                        except json.JSONDecodeError:
                            continue
                
                console.print(f"[green]Nuclei found {len(nuclei_findings)} potential vulnerabilities[/green]")
            else:
                console.print("[yellow]No Nuclei results file generated[/yellow]")
                
        except subprocess.TimeoutExpired:
            console.print("[yellow]Nuclei scan timed out after 10 minutes[/yellow]")
        except Exception as e:
            console.print(f"[red]Error running Nuclei: {str(e)}[/red]")
        
        return nuclei_findings

    def _run_ssl_scan(self) -> list:
        """Run SSL/TLS configuration analysis"""
        ssl_findings = []
        
        try:
            console.print("[cyan]Analyzing SSL/TLS configurations...[/cyan]")
            
            for target in list(self.live_subdomains):
                try:
                    # Use openssl to check SSL certificate
                    if self._is_ip_address(target):
                        cmd = ['openssl', 's_client', '-connect', f"{target}:443"]
                    else:
                        cmd = ['openssl', 's_client', '-connect', f"{target}:443", '-servername', target]
                    
                    process = subprocess.run(cmd, input="\n", capture_output=True, text=True, timeout=15)
                    
                    ssl_info = {
                        'target': target,
                        'ssl_available': False,
                        'certificate_info': '',
                        'issues': []
                    }
                    
                    if process.returncode == 0:
                        ssl_info['ssl_available'] = True
                        
                        # Parse certificate information
                        if 'Certificate chain' in process.stdout:
                            ssl_info['certificate_info'] = 'Valid SSL certificate found'
                        
                        # Check for common SSL issues
                        if 'verify error' in process.stdout.lower():
                            ssl_info['issues'].append('Certificate verification error')
                        if 'self signed' in process.stdout.lower():
                            ssl_info['issues'].append('Self-signed certificate')
                        if 'expired' in process.stdout.lower():
                            ssl_info['issues'].append('Expired certificate')
                        if 'unable to verify' in process.stdout.lower():
                            ssl_info['issues'].append('Unable to verify certificate')
                    else:
                        ssl_info['issues'].append('SSL/TLS not available or accessible')
                    
                    ssl_findings.append(ssl_info)
                    
                except subprocess.TimeoutExpired:
                    ssl_findings.append({
                        'target': target,
                        'ssl_available': False,
                        'issues': ['SSL scan timeout']
                    })
                except Exception:
                    continue
                    
        except Exception as e:
            console.print(f"[yellow]SSL scan failed: {str(e)}[/yellow]")
        
        return ssl_findings

    def _run_whatweb_scan(self) -> list:
        """Run WhatWeb for technology detection"""
        whatweb_findings = []
        
        try:
            console.print("[cyan]Running WhatWeb technology detection...[/cyan]")
            
            for target in list(self.live_subdomains)[:15]:  # Limit to avoid timeout
                try:
                    if self._is_ip_address(target):
                        url = f"http://{target}"
                    else:
                        url = f"https://{target}"
                    
                    cmd = ['whatweb', '--log-json=reports/whatweb_temp.json', url]
                    subprocess.run(cmd, capture_output=True, timeout=30)
                    
                    if os.path.exists('reports/whatweb_temp.json'):
                        with open('reports/whatweb_temp.json', 'r') as f:
                            for line in f:
                                try:
                                    finding = json.loads(line.strip())
                                    finding['target'] = target
                                    whatweb_findings.append(finding)
                                except json.JSONDecodeError:
                                    continue
                        os.remove('reports/whatweb_temp.json')
                        
                except subprocess.TimeoutExpired:
                    continue
                except Exception:
                    continue
                    
        except Exception as e:
            console.print(f"[yellow]WhatWeb scan failed: {str(e)}[/yellow]")
        
        return whatweb_findings

    def _calculate_vulnerability_metrics(self, vuln_results: dict):
        """Calculate vulnerability metrics"""
        for finding in vuln_results['nuclei_findings']:
            severity = finding.get('severity', 'info').lower()
            vuln_results['total_vulnerabilities'] += 1
            
            if severity == 'critical':
                vuln_results['critical_count'] += 1
            elif severity == 'high':
                vuln_results['high_count'] += 1
            elif severity == 'medium':
                vuln_results['medium_count'] += 1
            elif severity == 'low':
                vuln_results['low_count'] += 1
            else:
                vuln_results['info_count'] += 1

    def _generate_vulnerability_report(self, vuln_results: dict, output_path: str):
        """Generate comprehensive vulnerability assessment PDF report"""
        
        class VulnPDF(FPDF):
            def __init__(self):
                super().__init__()
                self.logo_path = 'Images/logo.png' if os.path.exists('Images/logo.png') else None
            def header(self):
                # Simulate a vertical gradient background from #1B2D48 to #223A5F
                steps = 30
                for i in range(steps):
                    r1, g1, b1 = 27, 45, 72  # #1B2D48
                    r2, g2, b2 = 34, 58, 95  # #223A5F
                    r = int(r1 + (r2 - r1) * i / steps)
                    g = int(g1 + (g2 - g1) * i / steps)
                    b = int(b1 + (b2 - b1) * i / steps)
                    y = self.h * i / steps
                    self.set_fill_color(r, g, b)
                    self.rect(0, y, self.w, self.h / steps + 1, 'F')
                if self.logo_path:
                    try:
                        logo_width = 10
                        logo_height = 10
                        x_pos = self.w - logo_width - 10
                        self.image(self.logo_path, x_pos, 8, logo_width, logo_height)
                    except Exception:
                        pass
                self.set_font('Arial', 'B', 9)
                self.set_text_color(0, 255, 0)
                self.cell(0, 10, 'TrimurtiSec Penetration Testing Framework', 0, 0, 'L')
                self.ln(15)
            def footer(self):
                self.set_y(-15)
                self.set_font('Arial', '', 8)
                self.set_text_color(200, 200, 200)
                self.cell(0, 10, f'TrimurtiSec Report | Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")} | Page {self.page_no()}', 0, 0, 'C')
        
        pdf = VulnPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)
        font_family = 'Arial'
        console.print("[cyan]Using built-in Arial font for PDF generation[/cyan]")
        # Title Page - Large centered logo
        if pdf.logo_path:
            try:
                logo_width = 45
                logo_height = 45
                x_pos = (pdf.w - logo_width) / 2  # Center on page
                pdf.set_xy(x_pos, 30)
                pdf.image(pdf.logo_path, x_pos, 30, logo_width, logo_height)
                pdf.ln(55)
                # Add slogan below logo
                pdf.set_font(font_family, 'I', 14)
                pdf.set_text_color(255, 215, 0)  # Gold
                pdf.cell(0, 12, '"Three faces, one mission - Secure Everything."', 0, 1, 'C')
                pdf.ln(10)
            except Exception as e:
                console.print(f"[yellow]Could not load title page logo: {e}[/yellow]")
                pdf.ln(30)
        else:
            pdf.ln(30)
        pdf.set_font(font_family, 'B', 28)
        pdf.set_text_color(0, 255, 0)  # Green
        pdf.cell(0, 20, 'TrimurtiSec Penetration Test Report', 0, 1, 'C')
        pdf.set_font(font_family, 'B', 18)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 15, 'Vulnerability Assessment & Analysis', 0, 1, 'C')
        pdf.ln(20)
        pdf.set_font(font_family, '', 14)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 10, f"Target Domain: {self.target}", 0, 1, 'C')
        pdf.cell(0, 8, f"Assessment Date: {datetime.now().strftime('%B %d, %Y')}", 0, 1, 'C')
        pdf.cell(0, 8, f"Report Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}", 0, 1, 'C')
        pdf.ln(10)
        # Add classification and confidentiality notice
        pdf.ln(30)
        pdf.set_font(font_family, 'B', 12)
        pdf.set_text_color(255, 0, 0)  # Red
        pdf.cell(0, 8, 'CONFIDENTIAL - PENETRATION TEST REPORT', 0, 1, 'C')
        pdf.set_font(font_family, 'I', 10)
        pdf.set_text_color(255, 255, 255)
        pdf.ln(10)
        confidentiality_text = (
            "This document contains confidential and proprietary information. "
            "Distribution is restricted to authorized personnel only. "
            "This report is intended solely for the organization that commissioned the assessment."
        )
        words = confidentiality_text.split()
        line = ""
        for word in words:
            if pdf.get_string_width(line + word + " ") < 180:
                line += word + " "
            else:
                pdf.cell(0, 6, line.strip(), 0, 1, 'C')
                line = word + " "
        if line:
            pdf.cell(0, 6, line.strip(), 0, 1, 'C')
        # Add new page for executive summary
        pdf.add_page()
        pdf.ln(10)
        # Executive Summary Section
        pdf.set_font(font_family, 'B', 20)
        pdf.set_text_color(255, 215, 0)  # Gold
        pdf.cell(0, 15, 'EXECUTIVE SUMMARY', 0, 1, 'L')
        pdf.ln(5)
        # Calculate risk metrics
        total_vulns = vuln_results['total_vulnerabilities']
        critical_count = vuln_results['critical_count']
        high_count = vuln_results['high_count']
        medium_count = vuln_results['medium_count']
        # Executive summary content
        pdf.set_font(font_family, '', 12)
        pdf.set_text_color(255, 255, 255)
        exec_summary = (
            f"This penetration test report presents the findings from a comprehensive vulnerability assessment "
            f"conducted against {self.target}. The assessment utilized industry-standard tools including Nuclei, WhatWeb, and SSLyze to identify and analyze vulnerabilities "
            f"across the target's digital assets.\n\n"
            f"The assessment identified a total of {total_vulns} vulnerabilities, categorized as follows: "
            f"{critical_count} critical, {high_count} high, and {medium_count} medium severity issues. "
            f"This phase provides actionable intelligence for risk mitigation and security improvement.\n\n"
        )
        # Risk assessment based on findings
        if critical_count > 0:
            risk_level = "CRITICAL"
            risk_color = (255, 0, 0)
            risk_text = (
                "Critical vulnerabilities were discovered, representing immediate and severe risk to the organization. "
                "Prompt remediation is essential to prevent exploitation."
            )
        elif high_count > 0:
            risk_level = "HIGH"
            risk_color = (255, 0, 0)
            risk_text = (
                "High-severity vulnerabilities were identified. These issues could be exploited to compromise confidentiality, integrity, or availability. "
                "Timely remediation is strongly recommended."
            )
        elif medium_count > 0:
            risk_level = "MEDIUM"
            risk_color = (255, 165, 0)
            risk_text = (
                "Medium-severity vulnerabilities were found. While less urgent, these should be addressed to reduce the attack surface and prevent future exploitation."
            )
        elif total_vulns > 0:
            risk_level = "LOW"
            risk_color = (255, 255, 0)
            risk_text = (
                "Only low-severity vulnerabilities were detected. These pose minimal risk but should still be reviewed and remediated as part of a defense-in-depth strategy."
            )
        else:
            risk_level = "INFORMATIONAL"
            risk_color = (0, 255, 0)
            risk_text = (
                "No exploitable vulnerabilities were discovered. The organization's security posture is strong, but ongoing vigilance is necessary."
            )
        exec_summary += f"Based on the findings, the current risk level is assessed as {risk_level}. {risk_text}"
        # Wrap and display executive summary text
        words = exec_summary.split()
        line = ""
        for word in words:
            if pdf.get_string_width(line + word + " ") < 180:
                line += word + " "
            else:
                pdf.cell(0, 6, line.strip(), 0, 1, 'L')
                line = word + " "
        if line:
            pdf.cell(0, 6, line.strip(), 0, 1, 'L')
        pdf.ln(10)
        # Risk Level Box
        pdf.set_font(font_family, 'B', 14)
        pdf.set_text_color(risk_color[0], risk_color[1], risk_color[2])
        pdf.cell(0, 10, f'OVERALL RISK LEVEL: {risk_level}', 0, 1, 'C')
        pdf.ln(10)
        # Key Findings Box
        pdf.set_font(font_family, 'B', 16)
        pdf.set_text_color(255, 215, 0)  # Gold
        pdf.cell(0, 10, 'KEY FINDINGS', 0, 1, 'L')
        pdf.ln(5)
        # ... existing code ...
        
        try:
            pdf.output(output_path)
            console.print(f"[green]Vulnerability report generated successfully: {output_path}[/green]")
        except Exception as e:
            console.print(f"[red]Error generating vulnerability report: {e}[/red]")

    def _is_ip_address(self, address):
        try:
            socket.inet_aton(address)
            return True
        except socket.error:
            return False

    def get_results_for_analysis(self):
        """
        Returns the vulnerability scan results as a formatted string (JSON),
        suitable for AI analysis or reporting.
        """
        import os, json
        vuln_results = {
            'nuclei_findings': [],
            'ssl_findings': [],
            'whatweb_findings': [],
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'info_count': 0
        }
        report_path = 'reports/nuclei_vulnerability_results.json'
        if os.path.exists(report_path):
            with open(report_path, 'r') as f:
                vuln_results['nuclei_findings'] = [json.loads(line) for line in f if line.strip()]
        return json.dumps(vuln_results, indent=2)
