import socket
import subprocess
import json
import os
import time
import yaml
from rich.console import Console
from rich.progress import Progress
from typing import List, Dict, Set
from datetime import datetime
from fpdf import FPDF
from trimurti.utils.enhanced_progress import TrimurtiProgressTracker, AnimatedSpinner, create_hacking_simulation_progress
import concurrent.futures

console = Console()

class VulnerabilityScanner:
    def __init__(self, target, trivy_path=None, shodan_api_key=None):
        """
        :param target: Target domain or IP
        :param trivy_path: Path to directory or container image for Trivy scan (optional)
        :param shodan_api_key: Shodan API key for public exposure checks (optional)
        """
        self.target = target
        self.trivy_path = trivy_path
        self.shodan_api_key = shodan_api_key
        self.live_subdomains = set()
        # Create reports directory
        os.makedirs('reports', exist_ok=True)
        self._discover_live_subdomains()

    def _discover_live_subdomains(self):
        """Discover live subdomains from existing scan results or perform basic discovery"""
        # First, try to load from existing subdomain discovery results
        if os.path.exists('reports/httpx_results.json'):
            console.print("[cyan]Loading live subdomains from previous scan results...[/cyan]")
            with open('reports/httpx_results.json', 'r') as f:
                for line in f:
                    try:
                        result = json.loads(line.strip())
                        url = result.get('url', '').replace('https://', '').replace('http://', '')
                        if url:
                            self.live_subdomains.add(url)
                    except json.JSONDecodeError:
                        continue
            
            if self.live_subdomains:
                console.print(f"[green]Found {len(self.live_subdomains)} live subdomains from previous scan[/green]")
                return
        
        # If no previous results, perform basic subdomain discovery
        console.print("[cyan]No previous subdomain data found. Performing basic discovery...[/cyan]")
        
        # Add the main domain as a target
        if not self._is_ip_address(self.target):
            # Test if main domain is accessible
            try:
                cmd = f"httpx -u {self.target} -silent -mc 200,301,302 -json -o reports/temp_httpx.json"
                process = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
                
                if os.path.exists('reports/temp_httpx.json'):
                    with open('reports/temp_httpx.json', 'r') as f:
                        for line in f:
                            try:
                                result = json.loads(line.strip())
                                url = result.get('url', '').replace('https://', '').replace('http://', '')
                                if url:
                                    self.live_subdomains.add(url)
                            except json.JSONDecodeError:
                                continue
                    os.remove('reports/temp_httpx.json')
            except Exception:
                pass
        
        # If it's an IP address, add it directly
        if self._is_ip_address(self.target):
            self.live_subdomains.add(self.target)
        elif not self.live_subdomains:
            # Add main domain anyway for scanning
            self.live_subdomains.add(self.target)

    def scan_vulnerabilities(self) -> str:
        """Run comprehensive vulnerability scanning"""
        if not self.live_subdomains:
            return "No live targets found for vulnerability scanning."
        
        # Create enhanced progress tracker
        tracker = TrimurtiProgressTracker('brahma', self.target)
        tracker.create_mode_header()
        
        console.print(f"[cyan]Starting vulnerability assessment on {len(self.live_subdomains)} targets...[/cyan]")
        
        # Vulnerability scanning steps
        vuln_steps = [
            "Initializing vulnerability scanning engines...",
            "Installing and updating vulnerability databases...",
            "Performing comprehensive security assessment...",
            "Analyzing SSL/TLS configurations...",
            "Detecting web technologies and frameworks...",
            "Compiling vulnerability findings..."
        ]
        
        vuln_results = {
            'nuclei_findings': [],
            'ssl_findings': [],
            'whatweb_findings': [],
            'nikto_findings': [],
            'nmap_findings': [],
            'gobuster_findings': [],
            'testssl_findings': [],
            'wpscan_findings': [],
            'amass_findings': [],
            'trivy_findings': [],
            'shodan_findings': [],
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'info_count': 0
        }
        
        with tracker.create_scan_progress(len(vuln_steps)) as progress:
            for i, step in enumerate(vuln_steps):
                task = progress.add_task(step, total=100)
                
                # Execute actual vulnerability scanning steps
                if i == 1:  # Install and update tools
                    self._ensure_vuln_tools_installed()
                elif i == 2:  # Run Nuclei scan
                    urls_file = self._create_urls_file()
                    vuln_results['nuclei_findings'] = self._run_nuclei_scan(urls_file)
                elif i == 3:  # SSL analysis
                    vuln_results['ssl_findings'] = self._run_ssl_scan()
                elif i == 4:  # Technology detection
                    vuln_results['whatweb_findings'] = self._run_whatweb_scan()
                    vuln_results['nikto_findings'] = self._run_nikto_scan()
                    vuln_results['nmap_findings'] = self._run_nmap_scan()
                    vuln_results['gobuster_findings'] = self._run_gobuster_scan()
                    vuln_results['testssl_findings'] = self._run_testssl_scan()
                    vuln_results['wpscan_findings'] = self._run_wpscan_scan()
                    vuln_results['amass_findings'] = self._run_amass_scan()
                    vuln_results['trivy_findings'] = self._run_trivy_scan()
                    vuln_results['shodan_findings'] = self._run_shodan_scan()
                elif i == 5:  # Calculate metrics
                    self._calculate_vulnerability_metrics(vuln_results)
                
                # Animate progress
                for j in range(100):
                    progress.advance(task, 1)
                    if i in [1, 2, 3, 4]:  # Add delay for actual work phases
                        time.sleep(0.01)
        
        # Show completion statistics
        vuln_stats = {
            "Target": self.target,
            "Targets Scanned": len(self.live_subdomains),
            "Total Vulnerabilities": vuln_results['total_vulnerabilities'],
            "Critical Issues": vuln_results['critical_count'],
            "High Severity": vuln_results['high_count'],
            "Medium Severity": vuln_results['medium_count'],
            "Low Severity": vuln_results['low_count'],
            "Status": "Vulnerability Scan Complete"
        }
        tracker.show_completion_stats(vuln_stats)
        
        # Generate comprehensive vulnerability report
        report_file = f'reports/vulnerability_scan_report_{self.target.replace(".", "_")}.pdf'
        self._generate_vulnerability_report(vuln_results, report_file)
        console.print(f"[green]Vulnerability report saved to: {report_file}[/green]")
        
        return f"Vulnerability scanning complete. Found {vuln_results['total_vulnerabilities']} potential security issues."

    def _create_urls_file(self) -> str:
        """Create URLs file for scanning"""
        urls_file = 'reports/live_targets.txt'
        with open(urls_file, 'w') as f:
            for target in self.live_subdomains:
                if self._is_ip_address(target):
                    f.write(f"http://{target}\n")
                    f.write(f"https://{target}\n")
                else:
                    f.write(f"https://{target}\n")
                    f.write(f"http://{target}\n")
        return urls_file

    def _ensure_vuln_tools_installed(self):
        """Ensure vulnerability scanning tools are installed"""
        console.print("[cyan]Checking vulnerability scanning tools...[/cyan]")
        
        # Check Nuclei
        try:
            subprocess.run(['nuclei', '-version'], capture_output=True, check=True)
            console.log("Nuclei is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Installing Nuclei...[/yellow]")
            try:
                subprocess.run([
                    'go', 'install', '-v', 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest'
                ], check=True)
                console.log("Nuclei installed successfully")
            except Exception as e:
                console.print(f"[red]Failed to install Nuclei: {e}[/red]")
        
        # Update Nuclei templates
        try:
            console.print("[cyan]Updating Nuclei templates...[/cyan]")
            subprocess.run(['nuclei', '-update-templates'], capture_output=True, timeout=60)
            console.log("Nuclei templates updated")
        except Exception as e:
            console.print(f"[yellow]Could not update Nuclei templates: {e}[/yellow]")
        # Check Nikto
        try:
            subprocess.run(['nikto', '-Version'], capture_output=True, check=True)
            console.log("Nikto is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Nikto is not installed or not in PATH. Please install Nikto for web server vulnerability scanning.[/yellow]")
        # Nmap
        try:
            subprocess.run(['nmap', '--version'], capture_output=True, check=True)
            console.log("Nmap is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Nmap is not installed or not in PATH. Please install Nmap for advanced scanning.[/yellow]")
        # Gobuster
        try:
            subprocess.run(['gobuster', 'version'], capture_output=True, check=True)
            console.log("Gobuster is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Gobuster is not installed or not in PATH. Please install Gobuster for directory brute-forcing.[/yellow]")
        # testssl.sh
        if not os.path.exists('./testssl.sh/testssl.sh'):
            console.print("[yellow]testssl.sh not found in ./testssl.sh/. Please clone https://github.com/drwetter/testssl.sh and place it in the project root.[/yellow]")
        # wpscan
        try:
            subprocess.run(['wpscan', '--version'], capture_output=True, check=True)
            console.log("wpscan is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]wpscan is not installed or not in PATH. Please install wpscan for WordPress scanning.[/yellow]")
        # Amass
        try:
            subprocess.run(['amass', 'version'], capture_output=True, check=True)
            console.log("Amass is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Amass is not installed or not in PATH. Please install Amass for subdomain enumeration.[/yellow]")
        # Trivy
        try:
            subprocess.run(['trivy', '--version'], capture_output=True, check=True)
            console.log("Trivy is available")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Trivy is not installed or not in PATH. Please install Trivy for container/filesystem scanning.[/yellow]")
        # Shodan (API key required)
        try:
            subprocess.run(['shodan', 'info'], capture_output=True, check=True)
            console.log("Shodan CLI is available (API key required)")
        except (subprocess.CalledProcessError, FileNotFoundError):
            console.print("[yellow]Shodan CLI is not installed or not in PATH. Please install Shodan CLI and set your API key for public exposure checks.[/yellow]")

    def _run_nuclei_scan(self, urls_file: str) -> list:
        """Run Nuclei vulnerability scanner"""
        nuclei_findings = []
        nuclei_output = 'reports/nuclei_vulnerability_results.json'
        
        try:
            console.print("[cyan]Running Nuclei vulnerability scan...[/cyan]")
            
            # Run Nuclei with comprehensive templates
            cmd = [
                'nuclei',
                '-list', urls_file,
                '-json',
                '-o', nuclei_output,
                '-severity', 'critical,high,medium,low',
                '-tags', 'cve,xss,sqli,rce,lfi,ssrf,redirect,exposure,misconfig',
                '-timeout', '15',
                '-retries', '3',
                '-rate-limit', '50',
                '-stats'
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            
            if os.path.exists(nuclei_output):
                with open(nuclei_output, 'r') as f:
                    for line in f:
                        try:
                            finding = json.loads(line.strip())
                            nuclei_findings.append(finding)
                        except json.JSONDecodeError:
                            continue
                
                console.print(f"[green]Nuclei found {len(nuclei_findings)} potential vulnerabilities[/green]")
            else:
                console.print("[yellow]No Nuclei results file generated[/yellow]")
                
        except subprocess.TimeoutExpired:
            console.print("[yellow]Nuclei scan timed out after 10 minutes[/yellow]")
        except Exception as e:
            console.print(f"[red]Error running Nuclei: {str(e)}[/red]")
        
        return nuclei_findings

    def _run_ssl_scan(self) -> list:
        """Run SSL/TLS configuration analysis"""
        ssl_findings = []
        
        try:
            console.print("[cyan]Analyzing SSL/TLS configurations...[/cyan]")
            
            for target in list(self.live_subdomains):
                try:
                    # Use openssl to check SSL certificate
                    if self._is_ip_address(target):
                        cmd = ['openssl', 's_client', '-connect', f"{target}:443"]
                    else:
                        cmd = ['openssl', 's_client', '-connect', f"{target}:443", '-servername', target]
                    
                    process = subprocess.run(cmd, input="\n", capture_output=True, text=True, timeout=15)
                    
                    ssl_info = {
                        'target': target,
                        'ssl_available': False,
                        'certificate_info': '',
                        'issues': []
                    }
                    
                    if process.returncode == 0:
                        ssl_info['ssl_available'] = True
                        
                        # Parse certificate information
                        if 'Certificate chain' in process.stdout:
                            ssl_info['certificate_info'] = 'Valid SSL certificate found'
                        
                        # Check for common SSL issues
                        if 'verify error' in process.stdout.lower():
                            ssl_info['issues'].append('Certificate verification error')
                        if 'self signed' in process.stdout.lower():
                            ssl_info['issues'].append('Self-signed certificate')
                        if 'expired' in process.stdout.lower():
                            ssl_info['issues'].append('Expired certificate')
                        if 'unable to verify' in process.stdout.lower():
                            ssl_info['issues'].append('Unable to verify certificate')
                    else:
                        ssl_info['issues'].append('SSL/TLS not available or accessible')
                    
                    ssl_findings.append(ssl_info)
                    
                except subprocess.TimeoutExpired:
                    ssl_findings.append({
                        'target': target,
                        'ssl_available': False,
                        'issues': ['SSL scan timeout']
                    })
                except Exception:
                    continue
                    
        except Exception as e:
            console.print(f"[yellow]SSL scan failed: {str(e)}[/yellow]")
        
        return ssl_findings

    def _run_whatweb_scan(self) -> list:
        """Run WhatWeb for technology detection (parallelized and faster)"""
        whatweb_findings = []
        console.print("[cyan]Running WhatWeb technology detection (parallel)...[/cyan]")
        targets = list(self.live_subdomains)[:10]  # Lower limit for speed
        def scan_target(target):
            try:
                if self._is_ip_address(target):
                    url = f"http://{target}"
                else:
                    url = f"https://{target}"
                cmd = ['whatweb', '--log-json=reports/whatweb_temp_' + target.replace('.', '_') + '.json', url]
                subprocess.run(cmd, capture_output=True, timeout=10)
                findings = []
                temp_file = f'reports/whatweb_temp_{target.replace('.', '_')}.json'
                if os.path.exists(temp_file):
                    with open(temp_file, 'r') as f:
                        for line in f:
                            try:
                                finding = json.loads(line.strip())
                                finding['target'] = target
                                findings.append(finding)
                            except json.JSONDecodeError:
                                continue
                    os.remove(temp_file)
                return findings
            except subprocess.TimeoutExpired:
                return []
            except Exception:
                return []
        # Run in parallel
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            results = list(executor.map(scan_target, targets))
        for result in results:
            whatweb_findings.extend(result)
        return whatweb_findings

    def _run_nikto_scan(self) -> list:
        """Run Nikto web server vulnerability scanner on each live target"""
        nikto_findings = []
        console.print("[cyan]Running Nikto vulnerability scan...[/cyan]")
        for target in list(self.live_subdomains)[:10]:  # Limit to 10 for speed
            try:
                if self._is_ip_address(target):
                    url = f"http://{target}"
                else:
                    url = f"https://{target}"
                output_file = f"reports/nikto_{target.replace('.', '_')}.json"
                cmd = [
                    'nikto',
                    '-h', url,
                    '-Format', 'json',
                    '-output', output_file
                ]
                process = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
                if os.path.exists(output_file):
                    with open(output_file, 'r') as f:
                        try:
                            nikto_json = json.load(f)
                            nikto_findings.append({
                                'target': target,
                                'findings': nikto_json.get('vulnerabilities', nikto_json)
                            })
                        except Exception as e:
                            console.print(f"[yellow]Nikto JSON parse error for {target}: {e}[/yellow]")
                    os.remove(output_file)
            except subprocess.TimeoutExpired:
                console.print(f"[yellow]Nikto scan timed out for {target}[/yellow]")
            except Exception as e:
                console.print(f"[yellow]Nikto scan failed for {target}: {e}[/yellow]")
        console.print(f"[green]Nikto scan complete. {len(nikto_findings)} targets scanned.[/green]")
        return nikto_findings

    def _run_nmap_scan(self) -> list:
        """Run Nmap with aggressive and vulnerability scripts"""
        nmap_findings = []
        console.print("[cyan]Running Nmap vulnerability scan...[/cyan]")
        for target in list(self.live_subdomains):
            output_file = f"reports/nmap_{target.replace('.', '_')}.xml"
            cmd = [
                'nmap', '-A', '-sV', '--script', 'vuln', '-oX', output_file, target
            ]
            try:
                subprocess.run(cmd, capture_output=True, text=True, timeout=600)
                if os.path.exists(output_file):
                    with open(output_file, 'r') as f:
                        nmap_findings.append({'target': target, 'xml': f.read()})
                    os.remove(output_file)
            except Exception as e:
                console.print(f"[yellow]Nmap scan failed for {target}: {e}[/yellow]")
        return nmap_findings

    def _run_gobuster_scan(self) -> list:
        gobuster_findings = []
        console.print("[cyan]Running Gobuster directory brute-force...[/cyan]")
        wordlist = "/usr/share/wordlists/dirb/common.txt"  # Adjust as needed
        for target in list(self.live_subdomains)[:5]:
            url = f"http://{target}" if self._is_ip_address(target) else f"https://{target}"
            output_file = f"reports/gobuster_{target.replace('.', '_')}.txt"
            cmd = [
                'gobuster', 'dir', '-u', url, '-w', wordlist, '-o', output_file, '-q'
            ]
            try:
                subprocess.run(cmd, capture_output=True, text=True, timeout=120)
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        lines = f.readlines()
                        for line in lines:
                            if "Status:" in line:
                                gobuster_findings.append({'target': target, 'result': line.strip()})
                # Do NOT delete output_file, let user review if needed
            except Exception as e:
                console.print(f"[yellow]Gobuster scan failed for {target}: {e}[/yellow]")
        # Write all findings to a single JSON file for easy review
        try:
            with open('reports/gobuster_findings.json', 'w') as f:
                json.dump(gobuster_findings, f, indent=2)
        except Exception as e:
            console.print(f"[yellow]Failed to write gobuster findings JSON: {e}[/yellow]")
        return gobuster_findings

    def _run_testssl_scan(self) -> list:
        testssl_findings = []
        console.print("[cyan]Running testssl.sh for advanced SSL/TLS analysis...[/cyan]")
        for target in list(self.live_subdomains)[:5]:
            url = target
            output_file = f"reports/testssl_{target.replace('.', '_')}.txt"
            cmd = [
                './testssl.sh/testssl.sh', url, '--quiet', '--warnings', '--color', '0', '--out', output_file
            ]
            try:
                subprocess.run(cmd, capture_output=True, text=True, timeout=180)
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        testssl_findings.append({'target': target, 'result': f.read()})
                    os.remove(output_file)
            except Exception as e:
                console.print(f"[yellow]testssl.sh scan failed for {target}: {e}[/yellow]")
        return testssl_findings

    def _run_wpscan_scan(self) -> list:
        wpscan_findings = []
        console.print("[cyan]Running wpscan for WordPress vulnerability scanning...[/cyan]")
        for target in list(self.live_subdomains)[:5]:
            url = f"http://{target}" if self._is_ip_address(target) else f"https://{target}"
            output_file = f"reports/wpscan_{target.replace('.', '_')}.json"
            cmd = [
                'wpscan', '--url', url, '--format', 'json', '--output', output_file
            ]
            try:
                subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        try:
                            wpscan_json = json.load(f)
                            wpscan_findings.append({'target': target, 'findings': wpscan_json})
                        except Exception as e:
                            console.print(f"[yellow]wpscan JSON parse error for {target}: {e}[/yellow]")
                    os.remove(output_file)
            except Exception as e:
                console.print(f"[yellow]wpscan scan failed for {target}: {e}[/yellow]")
        return wpscan_findings

    def _run_amass_scan(self) -> list:
        amass_findings = []
        console.print("[cyan]Running Amass for subdomain enumeration...[/cyan]")
        for target in [self.target]:
            output_file = f"reports/amass_{target.replace('.', '_')}.txt"
            cmd = [
                'amass', 'enum', '-d', target, '-o', output_file
            ]
            try:
                subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        amass_findings.append({'target': target, 'subdomains': f.read().splitlines()})
                    os.remove(output_file)
            except Exception as e:
                console.print(f"[yellow]Amass scan failed for {target}: {e}[/yellow]")
        return amass_findings

    def _run_trivy_scan(self) -> list:
        trivy_findings = []
        if not self.trivy_path:
            console.print("[yellow]No Trivy path specified. Skipping Trivy scan.[/yellow]")
            return trivy_findings
        console.print(f"[cyan]Running Trivy scan on {self.trivy_path}...[/cyan]")
        output_file = f"reports/trivy_{os.path.basename(str(self.trivy_path)).replace('.', '_')}.json"
        cmd = [
            'trivy', 'fs' if os.path.isdir(self.trivy_path) else 'image', self.trivy_path, '--format', 'json', '--output', output_file
        ]
        try:
            subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            if os.path.exists(output_file):
                with open(output_file) as f:
                    try:
                        trivy_json = json.load(f)
                        trivy_findings.append({'target': self.trivy_path, 'findings': trivy_json})
                    except Exception as e:
                        console.print(f"[yellow]Trivy JSON parse error: {e}[/yellow]")
                os.remove(output_file)
        except Exception as e:
            console.print(f"[yellow]Trivy scan failed: {e}[/yellow]")
        return trivy_findings

    def _run_shodan_scan(self) -> list:
        shodan_findings = []
        if not self.shodan_api_key:
            console.print("[yellow]No Shodan API key specified. Skipping Shodan scan.[/yellow]")
            return shodan_findings
        console.print("[cyan]Running Shodan for public exposure checks...[/cyan]")
        for target in list(self.live_subdomains):
            # Only scan IP addresses with Shodan
            if not self._is_ip_address(target):
                continue
            try:
                cmd = [
                    'shodan', 'host', target,
                    '--apikey', self.shodan_api_key
                ]
                process = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                if process.returncode == 0 and process.stdout:
                    try:
                        shodan_json = json.loads(process.stdout)
                        shodan_findings.append({'target': target, 'findings': shodan_json})
                    except Exception:
                        shodan_findings.append({'target': target, 'findings': process.stdout})
                else:
                    shodan_findings.append({'target': target, 'error': process.stderr})
            except Exception as e:
                console.print(f"[yellow]Shodan scan failed for {target}: {e}[/yellow]")
        return shodan_findings

    def _calculate_vulnerability_metrics(self, vuln_results: dict):
        """Calculate vulnerability metrics"""
        for finding in vuln_results['nuclei_findings']:
            severity = finding.get('severity', 'info').lower()
            vuln_results['total_vulnerabilities'] += 1
            
            if severity == 'critical':
                vuln_results['critical_count'] += 1
            elif severity == 'high':
                vuln_results['high_count'] += 1
            elif severity == 'medium':
                vuln_results['medium_count'] += 1
            elif severity == 'low':
                vuln_results['low_count'] += 1
            else:
                vuln_results['info_count'] += 1

    def _generate_vulnerability_report(self, vuln_results: dict, output_path: str):
        """Generate comprehensive vulnerability assessment PDF report"""
        
        class VulnPDF(FPDF):
            def __init__(self):
                super().__init__()
                self.logo_path = 'Images/logo.png' if os.path.exists('Images/logo.png') else None
            def header(self):
                # Fill background with solid color #1B2D48
                self.set_fill_color(27, 45, 72)
                self.rect(0, 0, self.w, self.h, 'F')
                if self.logo_path:
                    try:
                        logo_width = 10
                        logo_height = 10
                        x_pos = self.w - logo_width - 10
                        self.image(self.logo_path, x_pos, 8, logo_width, logo_height)
                    except Exception:
                        pass
                self.set_font('Arial', 'B', 9)
                self.set_text_color(0, 255, 0)
                self.cell(0, 10, 'TrimurtiSec Penetration Testing Framework', 0, 0, 'L')
                self.ln(15)
            def footer(self):
                self.set_y(-15)
                self.set_font('Arial', '', 8)
                self.set_text_color(200, 200, 200)
                self.cell(0, 10, f'TrimurtiSec Report | Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")} | Page {self.page_no()}', 0, 0, 'C')
        
        pdf = VulnPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)
        font_family = 'Arial'
        console.print("[cyan]Using built-in Arial font for PDF generation[/cyan]")
        # Title Page - Large centered logo
        if pdf.logo_path:
            try:
                logo_width = 45
                logo_height = 45
                x_pos = (pdf.w - logo_width) / 2  # Center on page
                pdf.set_xy(x_pos, 30)
                pdf.image(pdf.logo_path, x_pos, 30, logo_width, logo_height)
                pdf.ln(55)
                # Add slogan below logo
                pdf.set_font(font_family, 'I', 14)
                pdf.set_text_color(255, 215, 0)  # Gold
                pdf.cell(0, 12, '"Three faces, one mission - Secure Everything."', 0, 1, 'C')
                pdf.ln(10)
            except Exception as e:
                console.print(f"[yellow]Could not load title page logo: {e}[/yellow]")
                pdf.ln(30)
        else:
            pdf.ln(30)
        pdf.set_font(font_family, 'B', 28)
        pdf.set_text_color(0, 255, 0)  # Green
        pdf.cell(0, 20, 'TrimurtiSec Penetration Test Report', 0, 1, 'C')
        pdf.set_font(font_family, 'B', 18)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 15, 'Vulnerability Assessment & Analysis', 0, 1, 'C')
        pdf.ln(20)
        pdf.set_font(font_family, '', 14)
        pdf.set_text_color(255, 255, 255)
        pdf.cell(0, 10, f"Target Domain: {self.target}", 0, 1, 'C')
        pdf.cell(0, 8, f"Assessment Date: {datetime.now().strftime('%B %d, %Y')}", 0, 1, 'C')
        pdf.cell(0, 8, f"Report Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}", 0, 1, 'C')
        pdf.ln(10)
        # Add classification and confidentiality notice
        pdf.ln(30)
        pdf.set_font(font_family, 'B', 12)
        pdf.set_text_color(255, 0, 0)  # Red
        pdf.cell(0, 8, 'CONFIDENTIAL - PENETRATION TEST REPORT', 0, 1, 'C')
        pdf.set_font(font_family, 'I', 10)
        pdf.set_text_color(255, 255, 255)
        pdf.ln(10)
        confidentiality_text = (
            "This document contains confidential and proprietary information. "
            "Distribution is restricted to authorized personnel only. "
            "This report is intended solely for the organization that commissioned the assessment."
        )
        words = confidentiality_text.split()
        line = ""
        for word in words:
            if pdf.get_string_width(line + word + " ") < 180:
                line += word + " "
            else:
                pdf.cell(0, 6, line.strip(), 0, 1, 'C')
                line = word + " "
        if line:
            pdf.cell(0, 6, line.strip(), 0, 1, 'C')
        # Add new page for executive summary
        pdf.add_page()
        pdf.ln(10)
        # Executive Summary Section
        pdf.set_font(font_family, 'B', 20)
        pdf.set_text_color(255, 215, 0)  # Gold
        pdf.cell(0, 15, 'EXECUTIVE SUMMARY', 0, 1, 'L')
        pdf.ln(5)
        # Calculate risk metrics
        total_vulns = vuln_results['total_vulnerabilities']
        critical_count = vuln_results['critical_count']
        high_count = vuln_results['high_count']
        medium_count = vuln_results['medium_count']
        # Executive summary content
        pdf.set_font(font_family, '', 12)
        pdf.set_text_color(255, 255, 255)
        exec_summary = (
            f"This penetration test report presents the findings from a comprehensive vulnerability assessment "
            f"conducted against {self.target}. The assessment utilized industry-standard tools including Nuclei, WhatWeb, and SSLyze to identify and analyze vulnerabilities "
            f"across the target's digital assets.\n\n"
            f"The assessment identified a total of {total_vulns} vulnerabilities, categorized as follows: "
            f"{critical_count} critical, {high_count} high, and {medium_count} medium severity issues. "
            f"This phase provides actionable intelligence for risk mitigation and security improvement.\n\n"
        )
        # Risk assessment based on findings
        if critical_count > 0:
            risk_level = "CRITICAL"
            risk_color = (255, 0, 0)
            risk_text = (
                "Critical vulnerabilities were discovered, representing immediate and severe risk to the organization. "
                "Prompt remediation is essential to prevent exploitation."
            )
        elif high_count > 0:
            risk_level = "HIGH"
            risk_color = (255, 0, 0)
            risk_text = (
                "High-severity vulnerabilities were identified. These issues could be exploited to compromise confidentiality, integrity, or availability. "
                "Timely remediation is strongly recommended."
            )
        elif medium_count > 0:
            risk_level = "MEDIUM"
            risk_color = (255, 165, 0)
            risk_text = (
                "Medium-severity vulnerabilities were found. While less urgent, these should be addressed to reduce the attack surface and prevent future exploitation."
            )
        elif total_vulns > 0:
            risk_level = "LOW"
            risk_color = (255, 255, 0)
            risk_text = (
                "Only low-severity vulnerabilities were detected. These pose minimal risk but should still be reviewed and remediated as part of a defense-in-depth strategy."
            )
        else:
            risk_level = "INFORMATIONAL"
            risk_color = (0, 255, 0)
            risk_text = (
                "No exploitable vulnerabilities were discovered. The organization's security posture is strong, but ongoing vigilance is necessary."
            )
        exec_summary += f"Based on the findings, the current risk level is assessed as {risk_level}. {risk_text}"
        # Wrap and display executive summary text
        words = exec_summary.split()
        line = ""
        for word in words:
            if pdf.get_string_width(line + word + " ") < 180:
                line += word + " "
            else:
                pdf.cell(0, 6, line.strip(), 0, 1, 'L')
                line = word + " "
        if line:
            pdf.cell(0, 6, line.strip(), 0, 1, 'L')
        pdf.ln(10)
        # Risk Level Box
        pdf.set_font(font_family, 'B', 14)
        pdf.set_text_color(risk_color[0], risk_color[1], risk_color[2])
        pdf.cell(0, 10, f'OVERALL RISK LEVEL: {risk_level}', 0, 1, 'C')
        pdf.ln(10)
        # Key Findings Box
        pdf.set_font(font_family, 'B', 16)
        pdf.set_text_color(255, 215, 0)  # Gold
        pdf.cell(0, 10, 'KEY FINDINGS', 0, 1, 'L')
        pdf.ln(5)
        # ... existing code ...
        
        try:
            pdf.output(output_path)
            console.print(f"[green]Vulnerability report generated successfully: {output_path}[/green]")
        except Exception as e:
            console.print(f"[red]Error generating vulnerability report: {e}[/red]")

    def _is_ip_address(self, address):
        try:
            socket.inet_aton(address)
            return True
        except socket.error:
            return False

    def get_results_for_analysis(self):
        """
        Returns the vulnerability scan results as a formatted string (JSON),
        suitable for AI analysis or reporting.
        """
        import os, json
        vuln_results = {
            'nuclei_findings': [],
            'ssl_findings': [],
            'whatweb_findings': [],
            'nikto_findings': [],
            'nmap_findings': [],
            'gobuster_findings': [],
            'testssl_findings': [],
            'wpscan_findings': [],
            'amass_findings': [],
            'trivy_findings': [],
            'shodan_findings': [],
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0,
            'info_count': 0
        }
        report_path = 'reports/nuclei_vulnerability_results.json'
        if os.path.exists(report_path):
            with open(report_path, 'r') as f:
                vuln_results['nuclei_findings'] = [json.loads(line) for line in f if line.strip()]
        return json.dumps(vuln_results, indent=2)
